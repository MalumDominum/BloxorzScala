# KPI Functional Programming
### Lab3 - Streams. Bloxorz game
Bloxorz - це гра, до якої ви можете отримати доступ тут. Як перший крок для цього завдання пройдіть її на декількох рівнях. 
Мета Bloxorz проста; Ви повинні перемістити свій прямокутний блок до отвору в кінці дошки, прокатуючи його, за найменшу кількість можливих ходів. Блок можна переміщати в 4 можливих напрямках, вліво, вправо, вгору, вниз, за допомогою відповідних клавіш на клавіатурі.
Ідея цього завдання полягає в кодуванні розв’язувача для спрощеної версії цієї гри, без додавання помаранчевої плитки, кіл чи хрестів на місцевості. Метою вашої програми є повернення точної послідовності клавіш для введення для  досягнення цільової позиції, враховуючи конфігурацію місцевості з початковою позицією та цільовою позицією. Звичайно, ми також будемо зацікавлені отримати найкоротший шлях.
Під час вирішення цієї вправи вам пропонується ознайомитися з документацією API Scala, яку ви можете знайти тут: http://www.scala-lang.org/api/current/index.html
### State-space Exploration
Теорія кодування розв'язувача для цієї гри насправді може бути застосована до багатьох різних проблем. Загальна проблема, яку ми намагаємось вирішити, полягає в наступному:
Ми починаємо з деякого початкового стану S і намагаємось досягти кінцевого стану T.
З кожного штату можливі переходи до інших станів, деякі з яких поза межами заданого простору.
Ми досліджуємо стани, починаючи від S, досліджуючи сусідів і слідуючи ланцюгу висновування, поки не дійдемо до Т. Існують різні способи дослідження простору станів. Однак базовими вважають наступні два:
пошук в глибину: коли ми бачимо новий стан, ми негайно досліджуємо його прямих сусідів і робимо це аж кінця, поки не досягнемо термінального стану. Потім ми відступаємо до першого не дослідженого сусіда і продовжуємо в тому ж ключі.
пошук в ширину: тут ми продовжуємо більш обережно. Коли ми знаходимо сусідів нашого теперішнього стану, ми досліджуємо кожного з них на кожному кроці. Потім відповідні сусіди цих станів зберігаються для подальшого вивчення.

### Налаштування гри
Почнемо з налаштування нашої платформи. trait GameDef міститиме всю логіку щодо того, як налаштована місцевість, представлені блоки та як вони рухаються.

### Позиції
Позиція на ігровій дошці представлена за допомогою case класу Pos (row: Int, col: Int), де row col представляють її координати. Коментар Scaladoc до класу Pos пояснює, як інтерпретувати координати:
Координата row позначає положення на вертикальній осі
Координата col використовується для горизонтальної осі
Координати збільшуються при русі вниз і вправо

`0 1 2 3   <- col axis`
`0 o o o o`
`1 o o o o`
`2 o # o o    # is at position Pos(2, 1)`
`3 o o o o`
`^`
`|`
`row axis`


### Місцевість
Ми представляємо свою місцевість як функцію від позицій до булевих значень:
`type Terrain = Pos => Boolean`
Функція повертає значення true для кожного положення, яке знаходиться всередині місцевості. Місцевість можна легко створити з подання рядка за допомогою методів у файлі StringParserTerrain.scala.
`def terrainFunction(levelVector: Vector[Vector[Char]]): Pos => Boolean = ???`
`def findChar(c: Char, levelVector: Vector[Vector[Char]]): Pos= ???`

### Блоки
У файлі GameDef.scala, блок - це кубоїд 2 x 1 x 1. Ми представляємо це як case class, який містить два поля, 2d-позицію обох кубів, з яких складається блок.
Отже, блок це `case class Block(b1: Pos, b2: Pos)` і може рухатися в чотирьох різних напрямках. Щоразу отримується новий блок. Для цього передбачені методи `left, right, up` та `down`.
Враховуючи це, тепер ви можете визначити метод isStanding, який повідомляє нам, чи стоїть Block чи ні:
`def isStanding: Boolean =???`

Далі реалізуємо метод isLegal на  Block, який повідомляє нам, знаходиться блок на місцевості чи поза нею:
`def isLegal: Boolean =???`

Нарешті, нам потрібно реалізувати метод, який створює початковий блок для нашого моделювання, блок, розташований в початковій позиції:
`def startBlock: Block =???`

### Переїзди та сусіди
Щоб записати, які рухи ми робимо під час навігації по блоку, ми представляємо чотири можливі ходи як `case objects:`
`sealed abstract class Move`
`case object Left  extends Move`
`case object Right extends Move`
`case object Up    extends Move`
`case object Down  extends Move`
Тепер ви можете реалізовувати функції neighbors і legalNeighbors onBlock, які повертають список кортежів: сусідні блоки, а також переміщення до них.

`def neighbors: List[(Block,Move)] = ???`
`def legalNeighbors: List[(Block,Move)] = ???`

### Вирішення гри
Тепер, коли все налаштовано, ми можемо зосередитися на власне кодуванні нашого вирішувача, який визначено у файлі Solver.scala.
Ми могли б представити шлях до рішення як LazyList[Block]. Однак нам також потрібно переконатися, що ми зберігаємо історію на шляху до рішення. Отже, шлях представляється як LazyList[(Block, List[Move])], де друга частина пари записує історію ходів на даний момент. Якщо не зазначено інше, останнім ходом є головний елемент List[Move].
Спочатку реалізуйте функцію done, яка перевіряє, чи ми досягли мети:
`def done(b: Block): Boolean =???`

### Finding Neighbors
Потім реалізуйте функцію neighborsWithHistory, яка за заданим блоком та його історією повертає лінивий список сусідніх блоків із відповідними ходами.
def neighborsWithHistory(b: Block, history: List[Move]): LazyList[(Block, List[Move])] = ???
Як уже згадувалося вище, історія впорядкована таким чином, що останнім кроком є голова списку. Якщо ви розглянете Level 1 таким, як визначено в Bloxorz.scala, тоді
`neighborsWithHistory(Block(Pos(1,1),Pos(1,1)), List(Left,Up))`

призводить до лінивого списку з наступними елементами (поданими у наборі):
`Set(`
` (Block(Pos(1,2),Pos(1,3)), List(Right,Left,Up)),`
` (Block(Pos(2,1),Pos(3,1)), List(Down,Left,Up))`
`)`
Ви повинні реалізувати наведений вище приклад як тестовий приклад у тестовому наборі BloxorzSuite.

### Уникнення зациклення
Досліджуючи шлях, ми також будемо відстежувати всі блоки, які ми бачили до цього часу, щоб не загубитися в циклах (наприклад, послідовності left-right-left-right). Реалізуйте функцію newNeighborsOnly для цього:
`def newNeighborsOnly(neighbors: LazyList[(Block, List[Move])],
                    explored: Set[Block]): LazyList[(Block, List[Move])] = ???`

Приклад використання:
`newNeighborsOnly(`
` Set(`
`   (Block(Pos(1,2),Pos(1,3)), List(Right,Left,Up)),`
`   (Block(Pos(2,1),Pos(3,1)), List(Down,Left,Up))`
` ).to(LazyList),`

 Set(Block(Pos(1,2),Pos(1,3)), Block(Pos(1,1),Pos(1,1)))
)

Повертає:
`Set(`
` (Block(Pos(2,1),Pos(3,1)), List(Down,Left,Up))`
`).to(LazyList)`

Знову ж таки, вам слід перетворити цей приклад на тест.
### Пошук рішень
Тепер до суті вирішувача. Реалізуйте функцію, яка, враховуючи початковий лінивий список та набір досліджених блоків, створює ледачий список, що містить можливі шляхи, починаючи з голови початкового ледачого списку:

`def from(initial: LazyList[(Block, List[Move])],`
`        explored: Set[Block]): LazyList[(Block, List[Move])] =???`

Примітка: зверніть увагу на те, як побудований шлях: як обговорювалось у вступі, ключовим для отримання найкоротшого шляху до проблеми є дослідження простору пошуком в ширину.

Підказка: ми реалізовували подібну функцію на лекції.

### Знаходження розв’язків
Нарешті, ми можемо визначити ледачий val pathsFromStart, який є лінивим списком усіх шляхів, що починаються з початкового блоку:
`lazy val pathsFromStart: LazyList[(Block, List[Move])] = ???`
Ми також можемо визначити pathToGoal, який є лінивим списком усіх можливих пар блоків разом з їх історією. Дійсно, до Риму може бути не одна дорога!
`lazy val pathsToGoal: LazyList[(Block, List[Move])] =???`

Наприкінець, ми визначаємо рішення, яке містить найкоротший списків переходів (або один із найкоротших), що ведуть до цілі.

Примітка: елемент head повернутого списку [Move] повинен представляти перший хід, який гравець повинен виконати з вихідної позиції.
`lazy val solution: List[Move] =???`

